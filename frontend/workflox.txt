-1) Onaj ko pulluje from Github ovaj projekat, morace u terminal navigirati to "frontend" folder i ukucati "npm install" kako bi instalirao sve packages from package.json,
    jer sam te biblioteke u koracima 0-X instalirao dok sam pravio frontend deo, tacnije u node_modules su se istalirali kodovi biblioteka, dok u packages.json samo je 
    upisano koje biblioteke sam instalirao. U .gitignore moram dodati node_modules folder, jer je ogroman, pa kada se pulluje projekat from Github, komandom "npm install" 
    ce sve iz package.json instalira i kreira node_modules folder.

0) Ovo je React TypeScript + .NET Core Finance projekat. Pored mog backend (.NET), koristim free FinancialModelingPrep API.

1) Kreiram "ReactTSAspNetCoreAppGithub" folder u kome cu kreirati "frontend" i "backend" foldere.

2) U VSC otvorim taj folder, pa otvorim CMD i kucam "npx create-react-app frontend --template typescript"
   i u "ReactTSAspNetCoreAppGithub" folderu dobijem "frontend" folder koji sadrzi sve sto treba za pokretanje React app (pogledaj Kreiranje i pokretanje React app.txt).
   Kad push ovaj frontend folder to Github, it wont push "node_modules" folder as normal behaviour, because it is too large and everything is written in package.json, so 
   node_modules is gonna be put in .gitignore (objasnjeno u -1 koraku). 

3) Za svaki kod, bolje koristiti .tsx file, nego .ts file, jer nekad compiler kuka ako je .ts file i za obican .ts file koji nema React component, pa ce kukati sigurno 
   kada u kodu ima React delova.

4) Instaliram VSC Extension "ES7+ React/Redux/React-Native snippets" from dsznajder publisher, da mogu da koristim u .tsx file "tsrafce" za TS kad pravim React components
   (da ne kucam onaj pocetni kod svaki put). ES7+ su najnovije JS paradigme da jezik bude moderan.

5) U src folder dodam Components i Pages foldere. 
   U Components stavljam sve React components, dok u Pages stavljam web pages koje sadrze odgovarajuce Components. 
   Za svaki Component imacu .tsx i .css file istog imena. U .tsx kucam sve, dok u .css samo CSS styling. Medjutim, koristicu Tailwind CSS, pa mi .css i ne treba.
   U Components pravim Card folder gde pravim Card.css i Card.tsx files.
   
6) Modifikujem App.tsx: built-in kod brisem iz return naredbe i dodam Card component.

7) Pokretanje ReactTS: mora terminal biti u "frontend" folderu i kucam "npm start" da otvori u Chrome applikaciju.

8) Brisem sve iz App.css i index.css, jer kucacu svoje kasnije za Tailwind. 

9) U Components folder pravim CardList folder with CardList.tsx i CardList.css files.

10) U Components folder pravim Search folder with Search.tsx i Search.css files.

11) Terminal navigiram u "frontend" folder i kucam "npm install axios --save" i "npm install --save-dev @types/axios" jer ocu axios sa tipovima (iako 
   ne mora u TS tj moze i obican axios kao u ReactJS jer axios version > 0.14.x podrzava TS). Pa kucam "npm install dotenv --save" jer kad napravim .env file 
   (u root lavel as package.json), moram imati ovo instalirano da bih mogo u ReactTS ocitati varijable iz .env file. Svaka .env variable mora imati "REACT_APP_" prefix.

12) U frontend folder dodam .env file, ali necu pisati API KEY za onaj sajt u njega, jer to je u api.tsx stavljeno 

13) u src folder dodam api.tsx file i company.d.ts file jer gadjam API sa nekog sajta dok u company.d.ts stavljam sve moguce tipove od tog API get
   .d.ts je TS Declaration file koji govori axios biblioteci u kom formatu ce biti podaci koje dohvata/salje i u .d.ts file se ne stavlja logika, vec samo tipovi.

14) U frontend folder "npm install --save-dev @types/uuid"

15) U Components folder dodam Portfolio folder gde dodam  AddPortfolio folder gde dodam AddPortofolio.tsx i AddPortfolio.css
    Dodao i jos ove Portfolio foldere

16) U frontend folderu kucam "npm install -D tailwindcss@^3.4.1", a onda "npx tailwindcss init" sto ce da nam napravi tailwind.config.js koji nam treba

17) u Components dodam Navbar (Navbar.tsx/css) and Hero folder (Hero.tsx/css) koje sa tailwindcss kodiram.

18) Dodajem React Router Dom da napravim zeljene stranice unutar app. U terminal navigiram "frontend" folder i kucam "npm install -save react-router-dom", pa 
    "npm install --save @types/react-router-dom" i pravim Routes folder i Pages folder. U terminal kucam "npm install react-router-dom@latest" da moze 
    createBrowserRouter from "react-router-dom".

19) U Pages folder dodam zeljene foldere gde svaki prestavlja stranicu neku.

20) u Components create Sidebar folder 

21) U terminal navigiram u "frontend" folder i kucam "npm install react-icons"

22) U Components kreiranje CompanyProfile i IncomeStatement 

23) U Pages folder kreiranje DesignGuide page

24) U Components folder kreiranje Table koju koristim u DesignGuide page

25) U Components folder kreiranje RatioList koji koristim u DesignGuide

26) U Components folder kreiranje BalanceSheet 

27) U terminalu "npm i react-spinners" (cd frontend pre toga) for loading 

28) U Components folde kreiranje Spinner

29) U Components folder kreiranje TenK

// Sada pravim .NET backend 
// Napravio sam .NET backend (pogledaj "backend" folder) i nastavljam dalje ovde u frontend 

30) Terminal navigiram u "frontend" folder i kucam "npm install react-toastify"

31) Kreiram Services folder za AuthService

31) Kreiram ErrorHandler folder za AuthService.tsx gde ima LoginAPi i RegisterAPI da gadjaju u .NET backendu corresponding apis

31) Kreiram Models folder za UserProfileToken

32) Kreiram Context folder za global states koje koriste sve Components inside UserProvider (za likom Login i Register )

33) Terminal navigiram u "frontend" folder i kucam  "npm install react-hook-form yup @hookform/resolvers", jer Yup sluzi za validaciju u formi

34) LoginPage folder kreiranje

35) RegisterPage kreiranje

36) U Routes folder kreiram ProtectedRoute.tsx 

37) StockComment kreiram koga dodajem u CompanyProfile

38) CommentService kreiram u Services folder

39) U Models kreiram CommentPost za prihvatanje return polja iz backend endpoint 

40) Create StockCommentList

41) U Models, Create CommentGetFromBackend za StockCommentList

42) PortfolioService kreiram

43) Kreiram u Models PortfolioGetFromBackend za PortfolioService

44) U terminal "npm install react-error-boundary" kako bih napravio ErrorBoundary component koja ce obmotati <App> jer sam sve BE i FE greske pohvatao u kodu bez ErrorBoundary.
ErrorBoundary se inace stavlja oko Component koja mzoe da erroruje pa da ne pukne app, nego da prikaze zeljenu poruku na ekranu.

45) Want make this FE as PWA: 

   Pogledaj PWA.txt 

   As i made react app via Create React App it is partially PWA already.
   I need to add serviceWorkerRegistration.ts in src folder sa kodom koji sam naso na netu (moze se napravi da Create React App ne brise ovaj kod prilikom kreiranja)
   U src/index.tsx dodajem zeljeni kod sa neta da registrujem serviceWorkerRegistration.
   U terminal kucam "npm run build" jer sam kao spreman da deploy my app to production. Svaki put kad azuriram app, moram da ukucam "npm run build" da bi se azurirao i production code.
   Nakon "npm run build " kucam "npm install serve"(samo jednom) pa "npx serve -s build" da se production code pokrene da vidim kako production izgleda.

46) U Pages napravim ForgotPasswordPage koju otvaram kad u LoginPage kliknem "Forgot Password". Zatim u .NET sam napravio ForgotPassword endpoint i namestio u Gamil smtp
    password da moze .NET da pristupa mom gmailu, pa na email stize link koji vodi u reset password page.

47) Napravim ResetPasswordPage da mogu da otvorim link iz email. Ova stranica imace formu new password and confirm password. Onda u BE napravim ResetPassword endpoint 
    koji ce obradjivati zahteve sa ove stranice

48) Na Homepage dodam Google mapu sa lokacijom zeljenom

49) Route level code splitting (Procitaj u Routes folderu sta je) dodajem u Routes.tsx 

50) React.memo() for child component 
      Do sada nisam koristio React.memo(), stoga kada parent component re-renders zbog promene varijable od koje zavisi, child component automatically re-renders iako se
    prop (koji mu parent poslao) of child komponent mozda i ne menja. Zato, koristim React.memo() da se child component re-render samo ako mu se prop (koji mu je parent 
    poslao) menja.
      Use React.memo() only if: 0) child component have props
                                1) child component DOESNT use context/state/Redux koje ga re-renderuju kad se zamene van tog component
                                2) props(value or functions) passed to child component RARELY changes
                                3) child component is expensive to load.
      Za function props, pogledaj useCallback dole ispod objasnjen, jer value props ne diram u ovom slucaju
      React.memo() adds small overhead, so use it only when really needed.
      Konkurenti za memo su: HomePage:   1)Hero - nema props pa otpada.
                                         2)GoogleMap - nema props pa otpada
                             SearchPage: 1)Search - odlican kandidat 
                                         2)ListPortfolio nema potrebe -> CardPortfolio moze -> DeletePortfolio nema potrebe jer prelagan je
                                         3)CardList -> Card moze -> AddPortfolio mozda i moze ali me vise i mrzi nadalje da radim ovo
                             CompanyPage: 1)Sidebar
                                          2)ComapnyDashboard-> Tile 
                                                             TenK
                                          3)CompanyProfile-> RatioList 
                                                           StockComment -> StockCommentList        
                                                                           StockCommentForm
                                          4)IncomeStatement -> Table
                                          5)BalanceSheet -> RatioList 
                                          6)Cahslflow -> Table 
                              
51) useCallback dodajem za function props of child component which is wrapped in React.memo()
   When a React component re-renders, any functions defined inside it are recreated from scratch, so they get new references in memory, 
 even if their logic is identical. useCallback prevents this recreation by caching the function.
    useCallback koristim in useEffect samo ako je funkcija within useEffect dependency za useEffect ili ako je funckija def van useEffect i koriscenja u bar 2 useEffect - ovo kod mene za sad nema.
    najcesce se koristi when passing functions to child components especially when children are optimized with React.memo()
    dont use it for simple child components where re-rendering is cheap, only for expensive ones 
   
   expensive child component which depends on function props only (only re-render when prop changes) should use React.memo => use useCallback in parent for these functions !!!

   dependency za useCallback je samo ona varijabla koja se CITA from outside of function wrapped in useCallback !!!
   ako funkcija1, koja koristi useCallback, u sebi poziva funckija2 koja je def u istom component kao funckcija1, funkcija2 mora da koristi useCallback i da bude u dependency u funckija1 !!

   Search/CardPortfolio/Card treba React.memo() => njegove props funkcije pravim da budu useCallback

52) useMemo for expensive computation inside component ali msm da nigde to nemam

53) Cypress for testing: 53.1) u frontend folder terminal "npm install --save-dev cypress" i pokrecem sa "npm cypress open"
                         53.2) modifikujem cypress.config.ts kao sto je sad takav da bude
                         53.3) napravim cypress folder ako nema, i automatski se kreiraju subfolder, dodam e2e.ts folder sa sadrzajem u njemu, modifikujem commands.ts sa sadrzajem u njemu
                               Krecem sa E2E test, jer prakticnije nego components.
                         53.4) u cypress pravim e2e (bas ovako da se zove) folder u kome pisem test fajlove (kodove)
                         53.5) CTRL + SHIFT + X  and find Cypress Helper " by Dmytro Shyshkin
                         53.6) Mora npm start + npx cypress open kako bi E2E testing mogo. Dok kad testiram components, onda samo npx cypress open. 
                         53.7) U e2e folderu postoji testiranje.txt gde je objasnjeno kako se testira i odakle se krece

54) Do sada sam koristio (Long-lived) Access Token (JWT) koji sam skladistio u localStorage. Ali to je XSS vulnerable jer localStorage je skladiste of Browser i svako mu pristupi lagano.
   Zamenio sam localStorage sa in-memory varijablom koja je XSS secured i njoj ne moze da se pristupi kroz browser. 
   Dodao sam, pored Access Token i Refresh Token - pogledaj "SPA Security Best Practice.txt". Zato sada menjam localStorage sa in-memory za JWT.
   Prvo sam u useAuthContext.tsx zamenio localStorage sa in-memory, a onda i u svim ostalim fajlovima, koji su koristili localStorage.getItem("token") sam to morao uraditi !!!!!!
   Dodao sam setInMemoryToken i getInMemoryToken u useAuthContext.

   Install "npm install jwt-decode" jer iz BE nisam poslao vreme nastanka access token ali automatski se salje to (kao za svaki BE-FE response) i onda nadjem kad je poruka u kojoj je JWT pristigla
 ova biblioteka sama proracuna kad je JWT dosao i sracuna koliko ce da traje.
   Modifikujem AxiosWithJWTForBackend (custom axios) da podrzi i credential: 'include' interceptor i da silent refresh access token ako je pri isteku automatically pri svakom protected endpoint request 
   Svi BE request za protected routes moraju biti preko AxiosWithJWTForBackend 
   Moram rucno poslati withCredentials:'include' u AuthService.tsx gde koristim obican axios, jer Login/Register Endpoints vracaju Cookie with RefreshToken, pa ako nema withCredentials, onda FE nece da prihvati 
   Da bi Cookie se poslao ka BE, moram https pokrenuti applikaciju a to je zeznuto:
      1) u .env dodajem HTTPS=true
                        SSL_CRT_FILE=./localhost.pem
                        SSL_KEY_FILE=./localhost-key.pem
         ova 2 fajla su untracked by github
      2) powershell run as admin: download chocolatey -> choco install mkcert -> cd to frontend folder -> mkcert localhost i 2 fajla navedena u .env se naprave bas gde treba
      3) npm start => https://localhost:3000 je i sada svaki put, dok ovi certificati koji su validni do okt 2027, bice https kad uradim npm start
      4) U BE Program.cs zameni da CORS prima https, a ne dosadasnji http ! 
      5) u AxiosWithJWTForBackend.tsx dodajem another axios instance koja sluzi samo za refreshAccessToken da ne bi axios koji inace koristim upao u deadlock i nikad ne pozvao refresh-token endpoint



