-1) Kada se ovaj projekat pull-uje from Github, moram da u terminal navigiram to "frontend" folder i ukucam "npm install" kako bi instalirao sve packages from package.json 
jer sam njih u koracima 0-43 instalirao dok sam pravio frontend deo tj u node_modules, ali u .gitignore node_modules ne ide jer veliki, vec sve je u package.json zapisano
sta moram putem "npm install" da uradim.

0) Ovo je React TypeScript + .NET Core Finance projekat. Pored mog backend, koristim free FinancialModelingPrep API.
   Pre ovoga, naucio sam sve iz ReactJS foldera.

1) Kreiram "react_ts_and_aspnetcore_app" folder i vodim racuna da su sve mala slova, jer, zbog npm and package.json, ne moze da se kreira React App velikim slovima.

2) U VSC otvorim taj folder. Pa otvorim CMD i kucam "npx create-react-app frontend --template typescript"
i u "react_ts_and_aspnetcore_app" folderu dobijem "frontend" folder koji sadrzi sve kao i za React JS app da sam kreirao. 
Kao i ReactJS, dobijem node_modules, public i src foldere + .gitignore, package-lock.json, package.json i tsconfig.json files.
Za razliku od ReactApp, necu brisati nista iz src za sada. 
Kad push ovaj frontend folder na github, it wont push "node_modules" folder as normal behaviour, because it is too large and everything is written in package.json

3) Bolje koristiti .tsx file, nego .ts file, jer nekad compiler kuka ako je .ts file i za obican .ts file koji nema React component.

4) Instaliram VSC Extension "ES7+ React/Redux/React-Native snippets" from dsznajder publisher, da mogu da koristim u .tsx file
"rafce" za JS ili "tsrafce" za TS kad pravim React components da ne kucam onaj pocetni kod svaki put. 

5) U src folder dodam Components i Pages foldere. 
   U Components stavljam sve React components, dok u Pages stavljam web pages koje sadrze pojedine Components. 
   Za svaki Component imacu .tsx i .css file istog imena. U .tsx kucam sve, dok u .css samo CSS styling. Medjutim, koristicu Tailwind CSS, pa mi .css i ne treba.
   U Components pravim Card folder gde pravim Card.css i Card.tsx files.
   
6) Modifikujem App.tsx: built-in kod brisem iz return naredbe i dodam Card component.

7) Pokretanje ReactTS: mora terminal biti u "frontend" folderu i kucam "npm start" da otvori u Chrome applikaciju.

8) Brisem sve iz App.css i index.css, jer kucacu svoje kasnije za Tailwind. 

9) U Components folder pravim CardList folder with CardList.tsx i CardList.css files.

10) U Components folder pravim Search folder with Search.tsx i Search.css files.

11) Terminal navigiram u "frontend" folder i kucam "npm install axios --save" i "npm install --save-dev @types/axios" jer ocu axios sa tipovima (iako 
ne mora u TS tj moze i obican axios kao u ReactJS jer axios version > 0.14.x podrzava TS). Pa kucam "npm install dotenv --save" jer kad napravim .env file (u root lavel as package.json), 
moram imati ovo instalirano da bih mogo u ReactTS ocitati varijable iz .env file. Svaka .env variable mora imati "REACT_APP_" prefix.

12) U frontend folder dodam .env file, ali necu pisati API KEY za onaj sajt u njega, jer to je u api.tsx stavljeno 

13) u src folder dodam api.tsx file i company.d.ts file jer gadjam API sa nekog sajta dok u company.d.ts stavljam sve moguce tipove od tog API get
.d.ts je TS Declaration file koji govori axios biblioteci u kom formatu ce biti podaci koje dohvata/salje i u .d.ts file se ne stavlja logika, vec 
samo tipovi.

14) U frontend folder "npm install --save-dev @types/uuid"

15) U Components folder dodam Portfolio folder gde dodam  AddPortfolio folder gde dodam AddPortofolio.tsx i AddPortfolio.css
    Dodao i jos ove Portfolio foldere

16) U frontend folderu kucam "npm install -D tailwindcss@^3.4.1", a onda "npx tailwindcss init" sto ce da nam napravi tailwind.config.js koji nam treba

17) u Components dodam Navbar (Navbar.tsx/css) and Hero folder (Hero.tsx/css) koje sa tailwindcss kodiram 

18) Dodajem React Router Dom da napravim zeljene stranice unutar app. U terminal navigiram "frontend" folder i kucam "npm install -save react-router-dom", pa "npm install --save @types/react-router-dom" 
i pravim Routes folder i Pages folder. U terminal kucam "npm install react-router-dom@latest" da moze createBrowserRouter from "react-router-dom".

19) U Pages folder dodam zeljene foldere gde svaki prestavlja stranicu neku.

20) u Components create Sidebar folder 

21) U terminal navigiram u "frontend" folder i kucam "npm install react-icons"

22) U Components kreiranje CompanyProfile i IncomeStatement 

23) U Pages folder kreiranje DesignGuide page

24) U Components folder kreiranje Table koju koristim u DesignGuide page

25) U Components folder kreiranje RatioList koji koristim u DesignGuide

26) U Components folder kreiranje BalanceSheet 

27) U terminalu "npm i react-spinners" (cd frontend pre toga) for loading 

28) U Components folde kreiranje Spinner

29) U Components folder kreiranje TenK

// Sada pravim .NET backend 
// Napravio sam .NET backend (pogledaj "backend" folder) i nastavljam dalje ovde u frontend 

30) Terminal navigiram u "frontend" folder i kucam "npm install react-toastify"

31) Kreiram Services folder za AuthService

31) Kreiram ErrorHandler folder za AuthService.tsx gde ima LoginAPi i RegisterAPI da gadjaju u .NET backendu corresponding apis

31) Kreiram Models folder za UserProfileToken

32) Kreiram Context folder za global states koje koriste sve Components inside UserProvider (za likom Login i Register )

33) Terminal navigiram u "frontend" folder i kucam  "npm install react-hook-form yup @hookform/resolvers", jer Yup sluzi za validaciju u formi

34) LoginPage folder kreiranje

35) RegisterPage kreiranje

36) U Routes folder kreiram ProtectedRoute.tsx 

37) StockComment kreiram koga dodajem u CompanyProfile

38) CommentService kreiram u Services folder

39) U Models kreiram CommentPost za prihvatanje return polja iz backend endpoint 

40) Create StockCommentList

41) U Models, Create CommentGetFromBackend za StockCommentList

42) PortfolioService kreiram

43) Kreiram u Models PortfolioGetFromBackend za PortfolioService

44) U terminal "npm install react-error-boundary" kako bih napravio ErrorBoundary component koja ce obmotati <App> jer sam sve BE i FE greske pohvatao u kodu bez ErrorBoundary.
ErrorBoundary se inace stavlja oko Component koja mzoe da erroruje pa da ne pukne app, nego da prikaze zeljenu poruku na ekranu.

45) Want make this FE as PWA: 
   PWA web app osobine:
      1) Installable - can be added to desktop
      1) No app store required - can install it from browser
      2) Offline-capable - via caching works without internet collection but cannot make api request
      3) Fast - loads fast even on slow network
      4) Responsive - works on mobile, tablet and desktop
      5) Secure - over HTTPS radi
      6) Push notifications

   Technologies behind PWA:
      1) Service workers - ackground script that handles caching, offline mode, push notifications
      2) Web App Manifest - JSON file defining app name, icon, theme, install behavior
      3) HTTPS - security

   As i made react app via Create React App it is partially PWA already.
   I need to add serviceWorkerRegistration.ts in src folder sa kodom koji sam naso na netu. Moze se napravi da Create React App ne brise ovaj kod prilikom kreiranja. 
   U src/index.tsx dodajem zeljeni kod sa neta da registrujem serviceWorkerRegistration.
   U terminal kucam "npm run build" jer sam kao spreman da deploy my app to production. Svaki put kad azuriram app, moram da ukucam ovo da bi se azurirao i production app.
   Nakon "npm run build " kucam "npm install serve" pa "npx serve -s build" da se ovo pokrene na serveru koji nije localhost da vidim kako production izgleda.

46) U Pages napravim ForgotPasswordPage koju otvaram kad u LoginPage kliknem "Forgot Password". Zatim u .NET sam napravio ForgotPassword endpoint i namestio u Gamil smtp password da moze .NET da pristupa mom gmailu
Na email stize link koji vodi u reset password page.

47) Napravim ResetPasswordPage da mogu da otvorim link iz email. Ova stranica imace formu new password and confirm password. Onda u BE napravim ResetPassword endpoint koji ce obradjivati zahteve sa ove stranice

48) Na Homepage dodam Google mapu sa lokacijom zeljenom

49) Route level code splitting (Procitaj u Routes folderu sta je) dodajem u Routes.tsx 

50) React.memo() for child component 
      Do sada nisam koristio React.memo(), stoga kada parent component re-renders zbog promene varijable od koje zavisi, child component automatically re-renders iako se prop (koji mu parent poslao) of child komponent mozda i ne menja.
   Zato, koristim React.memo() da se child component re-render samo ako mu se prop (koji mu je parent poslao) menja.
      Use React.memo() only if: 0) child component have props
                                1) child component DOESNT use context/state/Redux koje ga re-renderuju kad se zamene van tog component
                                2) props(value or functions) passed to child component RARELY changes
                                3) child component is expensive to load.
      Za function props, pogledaj useCallback dole ispod objasnjen, jer value props ne diram u ovom slucaju
      React.memo() adds small overhead, so use it only when really needed.
      Konkurenti za memo su: HomePage:   1)Hero - nema props pa otpada.
                                         2)GoogleMap - nema props pa otpada
                             SearchPage: 1)Search - odlican kandidat 
                                         2)ListPortfolio nema potrebe -> CardPortfolio moze -> DeletePortfolio nema potrebe jer prelagan je
                                         3)CardList -> Card moze -> AddPortfolio mozda i moze ali me vise i mrzi nadalje da radim ovo
                             CompanyPage: 1)Sidebar
                                          2)ComapnyDashboard-> Tile 
                                                             TenK
                                          3)CompanyProfile-> RatioList 
                                                           StockComment -> StockCommentList        
                                                                           StockCommentForm
                                          4)IncomeStatement -> Table
                                          5)BalanceSheet -> RatioList 
                                          6)Cahslflow -> Table 
                              
51) useCallback dodajem za function props of child component which is wrapped in React.memo()
   When a React component re-renders, any functions defined inside it are recreated from scratch, so they get new references in memory, 
 even if their logic is identical. useCallback prevents this recreation by caching the function.
    useCallback koristim in useEffect samo ako je funkcija within useEffect dependency za useEffect ili ako je funckija def van useEffect i koriscenja u bar 2 useEffect - ovo kod mene za sad nema.
    najcesce se koristi when passing functions to child components especially when children are optimized with React.memo()
    dont use it for simple child components where re-rendering is cheap, only for expensive ones 
   
   expensive child component which depends on function props only (only re-render when prop changes) should use React.memo => use useCallback in parent for these functions !!!

   dependency za useCallback je samo ona varijabla koja se CITA from outside of function wrapped in useCallback !!!
   ako funkcija1, koja koristi useCallback, u sebi poziva funckija2 koja je def u istom component kao funckcija1, funkcija2 mora da koristi useCallback i da bude u dependency u funckija1 !!

   Search/CardPortfolio/Card treba React.memo() => njegove props funkcije pravim da budu useCallback

   
52) useMemo for expensive computation inside component ali msm da nigde to nemam


