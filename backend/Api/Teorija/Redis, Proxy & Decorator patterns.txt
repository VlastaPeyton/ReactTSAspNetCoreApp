Proxy and Decorator pattern for Redis:

    1) Proxy pattern: CachedRepository acts as a proxy tj forwarding calls to underlyin Repository. Omogucava lazy loading. 

    2) Decorator pattern: Extend functionality of existing Repository by adding cache logic sto znaci da ova klasa mora da implementira IRepository bas kao sto je 
                         i Repository klasa morala da ga implementira + da doda svoju cache logiku u metode of Repository.
                          Dodavanjem CachedRepository kao Decorator za Repository, IRepository predstavljace CachedRepository u StockController, a CachedRepository mora da sadrzi Repository.
                          Scrutor NuGet omogucava ovo.

Znam sve cache strategije za Read/Write, ali koristicu cache-aside za Read i write-through za Write.
Mozda budem koristio TTL i da Redis automatski trazi najkoriscenije podatke iz baze.
           
Redis sve cuva u key-value formatu, gde value moze biti string(JSON) ili byte, ali najcesci je JSON tj string jer u .NET samo za string(json) postoji built-in metoda u IDistributedCache.
Key mora biti jedinstven i string formata zbog IDistributedCache, pa treba razmisliti koje polje iz zeljene klase bice key.

NuGet za Redis:
    Microsoft.Extensions.Caching.Distributed - IDistributedCache je built-in i predstavlja in-memory cache ako Redis ne povezemo sa IDistributedCache.
    Microsoft.Extensions.Caching.StackExchangeRedis - poveze Redis with IDistributedCache koji je built-in i sad ce on da predstavlja Redis.
    Scrutor za Decorator pattern kako ne bih morao u Program.cs da pisem veliki kod.

    U Program.cs Decorator pattern bez Scrutor: 
      builder.Services.AddScoped<IStockRepository, StockRepository>();
      builder.Services.AddScoped<IStockRepository, CachedStockRepository>();
      // Ako uradim ovako, override cu AddScoped<IStockRepository, StockRepository>(), a to ne zelim, vec moram ovako
      builder.Services.AddScoped<IBasketRepository>(provider =>
      {   
          var stockRepository = provider.GetService<StockRepository>();
          return new CachedStockRepository(stockRepository, provider.GetRequiredServices<IDistributedCache>());
      });
    
    U Program.cs Decorator pattern sa Scrutor:
      builder.Services.AddScoped<IStockRepository, StockRepository>();
      builder.Services.Decorate<IStockRepository, CachedStockRepository>();

Ocu za StockRepository da uradim Redis.

Redis cu iz Docker da koristim bas kao RabbitMQ sto sam.